import unittest
import copy
from pathlib import Path # For managing temp state file
from typing import Any, Dict, Optional, List

# Assuming relative imports are correct for your project structure
from ..SimulationEngine import custom_errors
from ..collection_management import create_index # Function under test
from ..SimulationEngine.db import DB, MongoDB, save_state, load_state # Import MongoDB class and state functions
from common_utils.base_case import BaseTestCaseWithErrorHandler # For assert_error_behavior
from pydantic import ValidationError # Import Pydantic's ValidationError for specific tests


class TestCreateIndex(BaseTestCaseWithErrorHandler):

    def setUp(self):
        """Set up test environment before each test."""
        super().setUp()
        # Reset DB to clean state
        DB.connections.clear()
        DB.current_conn = None
        DB.current_db = None

        # Ensure a specific connection is active for this test suite's setup
        DB.switch_connection("default_test_conn")

        # Populate DB for tests using MongoDB instance methods
        # Database: prod_db
        prod_db_obj = DB.use_database("prod_db")
        prod_db_obj["users"].insert_many([{"name": "Alice"}, {"name": "Bob"}])
        prod_db_obj["products"].insert_many([{"item": "Laptop"}, {"item": "Mouse"}])
        prod_db_obj["orders_2024_Q1"].insert_one({"order_id": "o1"})
        
        # Pre-existing indexes for prod_db.coll1 for testing collision scenarios
        if "coll1" not in prod_db_obj.list_collection_names():
            prod_db_obj.create_collection("coll1")
        
        # Create test indexes directly using mongomock
        prod_db_obj["coll1"].create_index([("fieldA", 1)], name="idx_A")
        prod_db_obj["coll1"].create_index([("fieldB", -1)], name="idx_B_desc")
        prod_db_obj["coll1"].create_index([("fieldA", 1), ("fieldB", -1)], name="compound_AB")
        
        if "empty_coll" not in prod_db_obj.list_collection_names():
            prod_db_obj.create_collection("empty_coll")
        
        # Database: staging_db
        staging_db_obj = DB.use_database("staging_db")
        staging_db_obj["tests_collection"].insert_one({"test_case": "case1"})

        # Database: db_with_special_char_collections
        special_db_obj = DB.use_database("db_with_special_char_collections")
        special_db_obj["coll-name-with-hyphens"].insert_one({})
        special_db_obj["coll.name.with.dots"].insert_one({})  
        special_db_obj["coll name with spaces"].insert_one({})
        
        DB.use_database("prod_db") # Set current_db back to prod_db for tests

    def tearDown(self):
        """Clean up test environment after each test."""
        super().tearDown()
        # Reset DB to clean state
        DB.connections.clear()
        DB.current_conn = None
        DB.current_db = None

    # Helper methods (_get_collection_object, _assert_index_exists, _get_index_count)
    # remain the same as in your provided code.
    def _get_collection_object(self, db_name, coll_name):
        """Helper method to get a collection object."""
        client = DB.connections[DB.current_conn]
        return client[db_name][coll_name]

    def _assert_index_exists(self, db_name, coll_name, index_name):
        """Helper method to assert that an index exists."""
        coll = self._get_collection_object(db_name, coll_name)
        indexes = coll.index_information()
        self.assertIn(index_name, indexes, f"Index '{index_name}' should exist in collection '{coll_name}'")

    def _get_index_count(self, db_name, coll_name):
        """Helper method to get the number of indexes in a collection."""
        coll = self._get_collection_object(db_name, coll_name)
        return len(coll.index_information())

    def _debug_indexes(self, db_name, coll_name):
        """Helper method to debug what indexes actually exist."""
        coll = self._get_collection_object(db_name, coll_name)
        indexes = coll.index_information()
        print(f"DEBUG: Indexes in {db_name}.{coll_name}: {indexes}")
        return indexes

    # Test cases for successful index creation
    def test_create_index_basic_success(self):
        db_name, coll_name = "prod_db", "users"
        keys_dict = {"name": 1}
        expected_index_name = "name_1"  # Default name generated by MongoDB

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)
        initial_index_count = self._get_index_count(db_name, coll_name)

        result = create_index(database=db_name, collection=coll_name, keys=keys_dict)

        self.assertEqual(result["name"], expected_index_name)
        self.assertEqual(result["status_message"], "index created successfully")
        self.assertEqual(self._get_index_count(db_name, coll_name), initial_index_count + 1)
        self._assert_index_exists(db_name, coll_name, expected_index_name)

    def test_create_index_with_custom_name_success(self):
        db_name, coll_name = "prod_db", "users"
        keys_dict = {"name": -1}
        custom_name = "custom_name_desc"
        
        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)
        initial_index_count = self._get_index_count(db_name, coll_name)

        result = create_index(database=db_name, collection=coll_name, keys=keys_dict, name=custom_name)

        self.assertEqual(result["name"], custom_name)
        self.assertEqual(result["status_message"], "index created successfully")
        self.assertEqual(self._get_index_count(db_name, coll_name), initial_index_count + 1)
        self._assert_index_exists(db_name, coll_name, custom_name)

    def test_create_compound_index_success(self):
        db_name, coll_name = "prod_db", "users"
        keys_dict = {"name": 1, "age": -1}
        expected_index_name = "name_1_age_-1"  # Default compound index name
        
        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)
        initial_index_count = self._get_index_count(db_name, coll_name)

        result = create_index(database=db_name, collection=coll_name, keys=keys_dict)

        self.assertEqual(result["name"], expected_index_name)
        self.assertEqual(result["status_message"], "index created successfully")
        self.assertEqual(self._get_index_count(db_name, coll_name), initial_index_count + 1)
        self._assert_index_exists(db_name, coll_name, expected_index_name)

    def test_create_index_on_empty_collection_success(self):
        db_name, coll_name = "prod_db", "empty_coll"
        keys_dict = {"field1": 1}
        expected_index_name = "field1_1"
        
        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)
        initial_index_count = self._get_index_count(db_name, coll_name)

        result = create_index(database=db_name, collection=coll_name, keys=keys_dict)

        self.assertEqual(result["name"], expected_index_name)
        self.assertEqual(result["status_message"], "index created successfully")
        self.assertEqual(self._get_index_count(db_name, coll_name), initial_index_count + 1)
        self._assert_index_exists(db_name, coll_name, expected_index_name)

    def test_create_index_on_collection_with_special_characters_success(self):
        db_name = "db_with_special_char_collections"
        coll_name = "coll-name-with-hyphens"
        keys_dict = {"field1": 1}
        expected_index_name = "field1_1"

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)
        initial_index_count = self._get_index_count(db_name, coll_name)

        result = create_index(database=db_name, collection=coll_name, keys=keys_dict)

        self.assertEqual(result["name"], expected_index_name)
        self.assertEqual(result["status_message"], "index created successfully")
        self.assertEqual(self._get_index_count(db_name, coll_name), initial_index_count + 1)
        self._assert_index_exists(db_name, coll_name, expected_index_name)

    # Cases for existing indexes
    def test_create_index_spec_exists_no_name_provided_reports_existing(self):
        db_name, coll_name = "prod_db", "coll1"
        keys_dict = {"fieldA": 1} # This spec matches an index set up as 'idx_A'

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)
        
        initial_index_count = self._get_index_count(db_name, coll_name)

        result = create_index(database=db_name, collection=coll_name, keys=keys_dict)

        # The function should find the existing index and return its name
        expected_name_of_existing_index = "idx_A"
        self.assertEqual(result["name"], expected_name_of_existing_index)
        self.assertIn("already exists", result["status_message"])
        self.assertIn(f"(name: '{expected_name_of_existing_index}')", result["status_message"])
        self.assertIn("no action taken", result["status_message"])
        self.assertEqual(self._get_index_count(db_name, coll_name), initial_index_count)

    def test_create_index_spec_exists_same_name_provided_reports_existing(self):
        db_name, coll_name = "prod_db", "coll1"
        keys_dict = {"fieldA": 1} # Matches spec of 'idx_A'
        provided_index_name = "idx_A" # User provides the original custom name

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)
        
        initial_index_count = self._get_index_count(db_name, coll_name)

        result = create_index(database=db_name, collection=coll_name, keys=keys_dict, name=provided_index_name)

        expected_returned_name = "idx_A"
        self.assertEqual(result["name"], expected_returned_name)
        # This specific path should yield the "name and specification already exists" message
        self.assertIn("index with this name and specification already exists", result["status_message"])
        self.assertIn("no action taken", result["status_message"])
        self.assertEqual(self._get_index_count(db_name, coll_name), initial_index_count)

    def test_create_index_spec_exists_different_name_provided_reports_existing(self):
        db_name, coll_name = "prod_db", "coll1"
        keys_dict = {"fieldA": 1} # Matches spec of 'idx_A'
        new_name_for_existing_spec = "alt_name_for_idx_A" # Different name provided

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)
        
        initial_index_count = self._get_index_count(db_name, coll_name)

        result = create_index(database=db_name, collection=coll_name, keys=keys_dict, name=new_name_for_existing_spec)

        # The function finds an index by spec and reports its actual name from index_information().
        expected_actual_name_of_existing_index_with_spec = "idx_A"
        self.assertEqual(result["name"], expected_actual_name_of_existing_index_with_spec)
        self.assertIn("specification already exists", result["status_message"].lower())
        self.assertIn(f"(name: '{expected_actual_name_of_existing_index_with_spec}')", result["status_message"])
        self.assertIn("no action taken", result["status_message"])
        self.assertEqual(self._get_index_count(db_name, coll_name), initial_index_count)


    # Error Cases: IndexExistsError (name collision, different spec)
    def test_create_index_raises_IndexExistsError_name_collision_different_spec(self):
        db_name, coll_name = "prod_db", "coll1"
        keys_dict = {"fieldC": 1}  # Different spec
        conflicting_name = "idx_A"  # Name already exists with different spec

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)

        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict, name=conflicting_name),
            custom_errors.IndexExistsError,
            f"An index with name '{conflicting_name}' already exists but with a different key specification: [('fieldA', 1)]."
        )

    # Error Cases: InvalidIndexSpecificationError
    def test_create_index_raises_InvalidIndexSpecificationError_empty_keys(self):
        db_name, coll_name = "prod_db", "users"
        keys_dict = {}  # Empty keys

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)

        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict),
            custom_errors.InvalidIndexSpecificationError,
            "Index 'keys' definition cannot be empty."
        )

    def test_create_index_raises_InvalidIndexSpecificationError_invalid_key_type(self):
        db_name, coll_name = "prod_db", "users"
        keys_dict = {"name": "invalid"}  # Invalid key type (should be int)

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)

        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict),
            custom_errors.InvalidIndexSpecificationError,
            "Invalid index type 'invalid' for field 'name'. Supported integer values are: [1, -1] (e.g., 1 for ascending, -1 for descending)."
        )

    def test_create_index_raises_InvalidIndexSpecificationError_invalid_name_with_dollar(self):
        db_name, coll_name = "prod_db", "users"
        keys_dict = {"name": 1}
        invalid_name = "index$name"  # Contains '$'

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)

        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict, name=invalid_name),
            custom_errors.InvalidIndexSpecificationError,
            "Index name cannot contain '$' character."
        )

    def test_create_index_raises_InvalidIndexSpecificationError_reserved_name(self):
        db_name, coll_name = "prod_db", "users"
        keys_dict = {"name": 1}
        reserved_name = "_id_"  # Reserved name

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)

        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict, name=reserved_name),
            custom_errors.InvalidIndexSpecificationError,
            "The index name '_id_' is reserved and cannot be used for a user-defined index."
        )

    def test_create_index_raises_InvalidIndexSpecificationError_empty_field_name(self):
        db_name, coll_name = "prod_db", "users"
        keys_dict = {"": 1}  # Empty field name

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)

        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict),
            custom_errors.InvalidIndexSpecificationError,
            "Index field names must be non-empty strings."
        )

    def test_create_index_raises_InvalidIndexSpecificationError_non_string_field_name(self):
        db_name, coll_name = "prod_db", "users"
        keys_dict = {123: 1}  # Non-string field name

        DB.switch_connection("default_test_conn")
        DB.use_database(db_name)

        # This will be caught by Pydantic validation first, not custom validation
        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict),
            custom_errors.ValidationError,
            "Input validation failed"
        )

    # Error Cases: ValidationError (Pydantic validation)
    def test_create_index_raises_ValidationError_empty_database_name(self):
        db_name = ""  # Empty database name
        coll_name = "users"
        keys_dict = {"name": 1}

        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict),
            custom_errors.ValidationError,
            "Input validation failed"
        )

    def test_create_index_raises_ValidationError_empty_collection_name(self):
        db_name = "prod_db"
        coll_name = ""  # Empty collection name
        keys_dict = {"name": 1}

        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict),
            custom_errors.ValidationError,
            "Input validation failed"
        )

    def test_create_index_raises_ValidationError_non_string_name(self):
        db_name = "prod_db"
        coll_name = "users"
        keys_dict = {"name": 1}
        invalid_name = 123  # Non-string name

        # This will be caught by Pydantic validation first, not the custom validation
        self.assert_error_behavior(
            lambda: create_index(database=db_name, collection=coll_name, keys=keys_dict, name=invalid_name),
            custom_errors.ValidationError,
            "Input validation failed"
        )


if __name__ == '__main__':
    unittest.main()